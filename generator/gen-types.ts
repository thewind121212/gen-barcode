import { OptionsField, TypeMapJavaScript, TypeMapGolang } from "./main";
import protobuf from "protobufjs";
import path from "path";
import fs from "fs";

const protoTypeToGo = (field: protobuf.Field): string => {
    const baseType = TypeMapGolang[field.type] || field.type;
    const isOptional = getOptionals(field);

    if (field.repeated) {
        return `[]${baseType}`;
    }

    if (isOptional) {
        return `*${baseType}`;
    }

    return baseType;
}

const protoTypeToTS = (field: protobuf.Field): string => {

    const baseType = TypeMapJavaScript[field.type] || field.type;

    if (field.repeated) {
        return `${baseType}[]`;
    }

    return baseType;
}

const getOptionals = (field: protobuf.Field): boolean => {
    return Boolean(field.toJSON()?.options?.[OptionsField])
}

// Generate TypeScript interfaces
const generateInterfaces = (namespace: protobuf.Namespace): string => {
    let output = "";

    namespace.nestedArray.forEach((nested) => {
        if (nested instanceof protobuf.Service) {
            return;
        }

        if (nested instanceof protobuf.Type) {
            // This is a message
            output += `\nexport interface ${nested.name} {\n`;
            // Iterate through all fields
            nested.fieldsArray.forEach((field) => {
                const tsType = protoTypeToTS(field);
                const isOptionalProperty = getOptionals(field)
                const optionalMarker = isOptionalProperty ? "?" : "";

                output += `  ${field.name}${optionalMarker}: ${tsType};\n`;
            });

            output += `}\n`;
        }
    });

    return output;
}


export const GenerateFileTypeScript = (pkg: protobuf.Namespace, packageName: string, protoDir: string) => {
    const interfaces = generateInterfaces(pkg);

    const divider = "//" + "=".repeat(50)

    const desc = `// This file was generated by the protobuf compiler. Do not edit.`;

    const fileContent = `${desc}\n${divider}\n${interfaces}\n${divider}`;

    const fileNameTypes = `${packageName}.d.ts`;

    // write all generated types into a shared `types` folder in repo root
    const rootDir = path.resolve(protoDir, "..", "..");
    const typesDir = path.join(rootDir, "types");
    const feTypesDir = path.join(rootDir, "fe", "src", "types");
    const beTypesDir = path.join(rootDir, "be", "types");

    if (!fs.existsSync(typesDir)) {
        fs.mkdirSync(typesDir, { recursive: true });
    }

    const feTargetPath = path.join(feTypesDir, fileNameTypes);
    const beTargetPath = path.join(beTypesDir, fileNameTypes);

    if (!fs.existsSync(feTargetPath)) {
        fs.writeFileSync(feTargetPath, fileContent);

    } else {
        const fileContent = fs.readFileSync(feTargetPath, "utf8");
        const oldContent = fileContent.split(divider)[1];
        const newContent = fileContent.replace(oldContent, interfaces);
        fs.writeFileSync(feTargetPath, newContent);
    }

    if (!fs.existsSync(beTargetPath)) {
        fs.writeFileSync(beTargetPath, fileContent);
    } else {
        const fileContent = fs.readFileSync(beTargetPath, "utf8");
        const oldContent = fileContent.split(divider)[1];
        const newContent = fileContent.replace(oldContent, interfaces);
        fs.writeFileSync(beTargetPath, newContent);
    }
}








